{
  "articleId": "internationalization_nextjs",
  "author": "Daniel Sanchez",
  "date": "09/08",
  "image": "/images/image-preview.jpg",
  "imageAlt": "otro dict.imageAlt en español",
  "paragraphs": [
    "Introducción",
    "Me considero un minero del código. Pueden existir librerías inmensas, pero eso no me quita las ganas de seguir picando. Hace un par de años me adentré en el desarrollo frontend y comencé a generar mis propias librerías. Entre todos los quebraderos de cabeza, uno de ellos fue la internacionalización.",
    "En este artículo quiero explicar cómo construí, desde cero, un sistema de internacionalización (i18n) en Next.js, evitando dependencias externas y manteniendo control total sobre la carga de diccionarios y la validación de claves. Si te interesa entender la arquitectura y problemas reales que tuve que resolver (con código), sigue leyendo.",
    "Quiero aclarar que esta es una solución particular: seguramente existan librerías con mucha más madurez y funcionalidad que la mía.",
    "Nota: Este artículo está basado en Next.js 13 con App Router, que permite importar JSON dinámicamente en el servidor. En versiones anteriores puede que esta técnica no funcione o necesite adaptaciones.",
    "Primer enfoque: internacionalización con diccionarios estáticos en Next.js",
    "Aquí mi primera iteración: queriendo ir por mi propio camino, empecé a montar un diccionario simple. Con esta librería buscaba tener el control de la carga y evitar el uso de funciones auxiliares para traducir cadenas fijas en el código.",
    "```js",
    "import \"server-only\";",
    "",
    "export type DictData = { [x: string]: string | string[] };",
    "export type Dict = { [x: string]: Promise<DictData> }",
    "export type Dicts = {",
    "  [x: string]: () => Dict;",
    "};",
    "",
    "const dictionaries: Dicts = {",
    "  en: () => ({",
    "    common: import(\"../languages/en/common.json\").then((module) => module.default),",
    "    sassprependviawebpack: import(\"../articles/en/sassprependviawebpack.json\").then(",
    "      (module) => module.default",
    "    ),",
    "  }),",
    "  es: () => ({",
    "    common: import(\"../languages/es/common.json\").then((module) => module.default),",
    "    sassprependviawebpack: import(\"../articles/es/sassprependviawebpack.json\").then(",
    "      (module) => module.default",
    "    ),",
    "  }),",
    "};",
    "",
    "export const getDictionary = async (locale: string) => dictionaries[locale]?.();",
    "```",
    "La función `getDictionary` devuelve un objeto donde cada clave apunta a una promesa que resuelve el JSON correspondiente a esa sección del diccionario (por ejemplo, \"common\" o \"sassprependviawebpack\"). Por eso, para acceder a los datos, necesitamos usar `await`.",
    "Por otro lado, la función `import` que ves aquí es la importación dinámica estándar de `ESM / ESModules`, que permite cargar los módulos de forma dinámica, lo que es útil para dividir el código y cargar solo lo necesario. En este caso, estamos importando los archivos JSON que contienen las traducciones.",
    "```js",
    "const fullDict = await getDictionary(lang);",
    "",
    "const common = await fullDict.common;",
    "console.log(common);",
    "// Ejemplo de Salida simplificada",
    "// { welcome: \"Bienvenido\", goodbye: \"Adiós\" }",
    "```",
    "Sencillo, ¿verdad? Con esto solo llamo a `getDictionary` y me devuelve todas las frases comunes y artículos.",
    "Problemas detectados: escalabilidad y organización",
    "Uno de los primeros problemas detectados fue la escalabilidad. ¿Qué pasa si quiero meter 15 idiomas más? Tendría que replicar el código para cada idioma, aumentando la deuda técnica y el riesgo de inconsistencias.",
    "No solo eso: además de mis artículos, quiero poder incluir mis proyectos con toda su información, pero ¿cómo diferenciarlos de los artículos?; Necesito la posibilidad de incluir traducciones de diferentes tipos de contenido y no está claro cómo diferenciarlos correctamente.",
    "Segunda iteración: estructura modular y loader dinámico",
    "Con esto, planteé una separación de responsabilidades: cada objeto sería lo que necesita ser, ya sea un diccionario común, artículos o proyectos.",
    "Junto a esto, un `loader` que carga con una configuración concreta y que los diccionarios adhirieran para poder cargarlos todos.",
    "El nuevo código queda de esta manera:",
    "```js",
    "import \"server-only\";",
    "import { i18n } from \"../../../../../i18n.config\";",
    "",
    "export type DictData = {",
    "      [x: string",
    "      ]: string | string[]",
    "    };",
    "export type Dict = {",
    "      [x: string",
    "      ]: Promise<DictData>",
    "    };",
    "export type Dicts = {",
    "      [x: string",
    "      ]: () => Dict;",
    "    };",
    "export type Path = {",
    "  folder: string;",
    "  names: string[];",
    "    };",
    "",
    "const dictionaries: Dicts = {};",
    "const commonDictionaries: Path = {",
    "  folder: \"languages\",",
    "  names: [",
    "        \"common\"",
    "      ],",
    "    };",
    "const articles: Path = {",
    "  folder: \"articles\",",
    "  names: [",
    "        \"sassprependviawebpack\",",
    "        \"anotherarticle\"",
    "      ],",
    "    };",
    "const projects: Path = {",
    "  folder: 'projects',",
    "  names: ['codingflavour', 'portfolio'",
    "      ],",
    "    }",
    "const fullDictionaries = [commonDictionaries, articles, projects",
    "    ];",
    "",
    "for (let lang of i18n.locales) {",
    "  let art: Dict = {};",
    "  for (let dictionaries of fullDictionaries) {",
    "    for (let name of dictionaries.names) {",
    "      art[name",
    "          ] = import(`../${dictionaries.folder",
    "          }/${lang",
    "          }/${name",
    "          }.json`).then(",
    "        (module) => module.default",
    "      );",
    "        }",
    "      }",
    "  dictionaries[lang",
    "      ] = () => ({",
    "    ...art,",
    "      });",
    "    }",
    "",
    "export { articles, projects",
    "    };",
    "export const getDictionary = async (locale: string) => dictionaries[locale]?.();",
    "```",
    "Con un ejemplo de su uso:",
    "",
    "```js",
    "const fullDict = await getDictionary(lang);",
    "",
    "const common = await fullDict.common;",
    "const article = await fullDict.sassprependviawebpack;",
    "console.log(common.welcome); // \"Welcome\"",
    "console.log(article.header); // \"Sass Prepend via Webpack\"",
    "```",
    "Resuelto el problema de escalabilidad y de identificación de responsabilidades.",
    "",
    "Próximos pasos: sincronización y validación",
    "",
    "Si te fijas, aún tenemos algunos problemas, unos más graves, otros no tanto.",
    "",
    "- La carga de diccionarios es asíncrona y usamos un Singleton.",
    "- En sistemas multi-petición, el objeto podría ser sobreescrito en peticiones concurrentes, generando problemas con promesas ya resueltas.",
    "- No existe ningún tipo de validación de las claves.",
    "- Todos los componentes que intentan usar un diccionario específico necesitan esperarlo con `await`, aunque no siempre sea necesario.",
    "",
    "```js",
    "  const fullDict = await getDictionary(lang);",
    "",
    "  const common = await fullDict.common;",
    "```",
    "",
    "Todo esto y más en nuestro siguiente artículo: \"Generando un sistema de internacionalización desde cero en NextJS: La sincronización\""
  ],
  "title": "Generando un sistema de internacionalizacion desde cero en NextJS (i18n)",
  "description": "En este artículo, exploraremos cómo construir un sistema de internacionalización desde cero en NextJS, abordando los desafíos y soluciones en el camino."
}